/**
 * Kafka Exception Handling
 * This is an application to show kafka data.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: balu.vyamajala@amway.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent } from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs/Observable';

import { PartitionContent } from '../model/partitionContent';
import { PartitionOffset } from '../model/partitionOffset';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { UtilService } from '../services/util/util.service';

@Injectable()
export class ConsumerService {
    protected basePath = '/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional() configuration: Configuration) {
        this.basePath = UtilService.getBaseUrl() + this.basePath;

        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * Fetch Data from topic
     * consume data from Topic
     * @param topicName Topic Name
     * @param consumerGroup Consumer Group
     * @param position Position
     * @param partitionOffset PartitionOffset
     * @param noOfRecordsPerPartition No of Records per partition
     * @param searchKeys search Keys
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public consumeFromTopic(
        topicName: string,
        consumerGroup: string,
        position: string,
        partitionOffset: Array<PartitionOffset>,
        noOfRecordsPerPartition?: number,
        searchKeys?: string,
        observe?: 'body',
        reportProgress?: boolean
    ): Observable<Array<PartitionContent>>;
    public consumeFromTopic(
        topicName: string,
        consumerGroup: string,
        position: string,
        partitionOffset: Array<PartitionOffset>,
        noOfRecordsPerPartition?: number,
        searchKeys?: string,
        observe?: 'response',
        reportProgress?: boolean
    ): Observable<HttpResponse<Array<PartitionContent>>>;
    public consumeFromTopic(
        topicName: string,
        consumerGroup: string,
        position: string,
        partitionOffset: Array<PartitionOffset>,
        noOfRecordsPerPartition?: number,
        searchKeys?: string,
        observe?: 'events',
        reportProgress?: boolean
    ): Observable<HttpEvent<Array<PartitionContent>>>;
    public consumeFromTopic(
        topicName: string,
        consumerGroup: string,
        position: string,
        partitionOffset: Array<PartitionOffset>,
        noOfRecordsPerPartition?: number,
        searchKeys?: string,
        observe: any = 'body',
        reportProgress: boolean = false
    ): Observable<any> {
        if (topicName === null || topicName === undefined) {
            throw new Error('Required parameter topicName was null or undefined when calling consumeFromTopic.');
        }
        if (consumerGroup === null || consumerGroup === undefined) {
            throw new Error('Required parameter consumerGroup was null or undefined when calling consumeFromTopic.');
        }
        if (position === null || position === undefined) {
            throw new Error('Required parameter position was null or undefined when calling consumeFromTopic.');
        }
        if (partitionOffset === null || partitionOffset === undefined) {
            throw new Error('Required parameter partitionOffset was null or undefined when calling consumeFromTopic.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (topicName !== undefined) {
            queryParameters = queryParameters.set('topicName', <any>topicName);
        }
        if (consumerGroup !== undefined) {
            queryParameters = queryParameters.set('consumerGroup', <any>consumerGroup);
        }
        if (position !== undefined) {
            queryParameters = queryParameters.set('position', <any>position);
        }
        if (noOfRecordsPerPartition !== undefined) {
            queryParameters = queryParameters.set('noOfRecordsPerPartition', <any>noOfRecordsPerPartition);
        }
        if (searchKeys !== undefined) {
            queryParameters = queryParameters.set('searchKeys', <any>searchKeys);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<PartitionContent>>(`${this.basePath}/consumer/fetch`, partitionOffset, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }

    /**
     * Initialize Consumer Instance
     * Initialize consumer instance.
     * @param topicName Topic Name
     * @param consumerGroup Consumer Group
     * @param partitionOffset PartitionOffset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public initializeConsumerInstance(
        topicName: string,
        consumerGroup: string,
        partitionOffset: Array<PartitionOffset>,
        observe?: 'body',
        reportProgress?: boolean
    ): Observable<any>;
    public initializeConsumerInstance(
        topicName: string,
        consumerGroup: string,
        partitionOffset: Array<PartitionOffset>,
        observe?: 'response',
        reportProgress?: boolean
    ): Observable<HttpResponse<any>>;
    public initializeConsumerInstance(
        topicName: string,
        consumerGroup: string,
        partitionOffset: Array<PartitionOffset>,
        observe?: 'events',
        reportProgress?: boolean
    ): Observable<HttpEvent<any>>;
    public initializeConsumerInstance(
        topicName: string,
        consumerGroup: string,
        partitionOffset: Array<PartitionOffset>,
        observe: any = 'body',
        reportProgress: boolean = false
    ): Observable<any> {
        if (topicName === null || topicName === undefined) {
            throw new Error(
                'Required parameter topicName was null or undefined when calling initializeConsumerInstance.'
            );
        }
        if (consumerGroup === null || consumerGroup === undefined) {
            throw new Error(
                'Required parameter consumerGroup was null or undefined when calling initializeConsumerInstance.'
            );
        }
        if (partitionOffset === null || partitionOffset === undefined) {
            throw new Error(
                'Required parameter partitionOffset was null or undefined when calling initializeConsumerInstance.'
            );
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (topicName !== undefined) {
            queryParameters = queryParameters.set('topicName', <any>topicName);
        }
        if (consumerGroup !== undefined) {
            queryParameters = queryParameters.set('consumerGroup', <any>consumerGroup);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = ['application/json'];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/consumer/init`, partitionOffset, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }

    /**
     * Keep Consumer Instance Alive
     * Keep Consumer Instance Alive
     * @param topicName Topic Name
     * @param consumerGroup Consumer Group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public keepAlive(
        topicName: string,
        consumerGroup: string,
        observe?: 'body',
        reportProgress?: boolean
    ): Observable<any>;
    public keepAlive(
        topicName: string,
        consumerGroup: string,
        observe?: 'response',
        reportProgress?: boolean
    ): Observable<HttpResponse<any>>;
    public keepAlive(
        topicName: string,
        consumerGroup: string,
        observe?: 'events',
        reportProgress?: boolean
    ): Observable<HttpEvent<any>>;
    public keepAlive(
        topicName: string,
        consumerGroup: string,
        observe: any = 'body',
        reportProgress: boolean = false
    ): Observable<any> {
        if (topicName === null || topicName === undefined) {
            throw new Error('Required parameter topicName was null or undefined when calling keepAlive.');
        }
        if (consumerGroup === null || consumerGroup === undefined) {
            throw new Error('Required parameter consumerGroup was null or undefined when calling keepAlive.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (topicName !== undefined) {
            queryParameters = queryParameters.set('topicName', <any>topicName);
        }
        if (consumerGroup !== undefined) {
            queryParameters = queryParameters.set('consumerGroup', <any>consumerGroup);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = ['application/json'];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [];

        return this.httpClient.post<any>(`${this.basePath}/consumer/keepAlive`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
